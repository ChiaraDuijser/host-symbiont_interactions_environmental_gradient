---
title: "Symbiodiniaceae diversity (Sequences, Profiles, PERMANOVA)"
author: "Chiara Duijser"
date: "2023-04-23"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require("knitr")
opts_knit$set(root.dir = "~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/")
```

# Set working directory 
```{r user_definitions}
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/")
```

```{r}
# Packages required to analyse this data. If you do not have them, please install them.
library(tidyverse)
library(kmer)
library(phangorn)
library(GUniFrac)
library(ggtree)
library(patchwork)
library(bioseq)
library(ape)
library(Biostrings)
library(usedist)
library(plotly)

# Custom functions for loading and handling fasta files
dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}

read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}
```

# Read in and format the **sequence** tables

**Metadata now includes an extra column *population* which contains the populations based on STRUCTURE and DAPC analysis** 
CLONE is included!!!!

```{r}
# Import sequence table
seqs <- read_tsv("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/20230421T034816_cduijser/post_med_seqs/259_20230421T204816_DBV_20230422T042656.seqs.absolute.abund_and_meta.txt") %>%
    mutate(sample_name = as.factor(sample_name)) %>%
    filter(!(is.na(sample_name))) # remove the final empty row; see Excel or text file row 98 "seq_accession"
#ANY SAMPLES NOT TO BE ANALYSED ADD ANOTHER FILTER HERE. Row = seq_accession but nothing more in other cells.

# Import sample_name metadata
meta <- read.csv("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/230423 metadata_species_colony_position_CMD_HYBRID_2.csv", sep=",")

str(meta)
meta$habitat <- as.factor(meta$habitat)
meta$habitat <- factor(meta$habitat, levels=c("Outer reef", "Inner reef", "Outer mangrove", "Inner mangrove"))
meta$population <- as.factor(meta$population)
levels(meta$population)
meta$population <- factor(meta$population, levels = c("Reef", "Mangrove", "Hybrid"))
meta$colony_position <- as.factor(meta$colony_position)
meta$sample_name <- as.factor(meta$sample_name)

meta$sample_name <- factor(meta$sample_name, levels = c("CD_1", "CD_2", "CD_3", "CD_4A.3", "CD_5", "CD_6A.3", "CD_7A.3", "CD_8A.3", "CD_9", "CD_10", "CD_11A", "CD_12", "CD_13A", "CD_14", "CD_15", "CD_16", "CD_17", "CD_18", "CD_19", "CD_20", "CD_21A", "CD_22A", "CD_23", "CD_24", "CD_41A", "CD_42A", "CD_43A", "CD_44A.2", "CD_45A", "CD_46A", "CD_47", "CD_48", "CD_49A", "CD_50_rd_CL", "CD_51.2", "CD_52", "CD_53", "CD_54A", "CD_55", "CD_56", "CD_57A", "CD_58A", "CD_59A", "CD_60", "CD_61A", "CD_62A", "CD_63.2", "CD_64A", "CD_81A", "CD_82A.2", "CD_83", "CD_84A", "CD_85A", "CD_86A_rd_CL", "CD_87", "CD_88A", "CD_89A", "CD_90A", "CD_91", "CD_92", "CD_93_rd_CL", "CD_94", "CD_95.2", "CD_96.2", "CD_97", "CD_98A", "CD_99", "CD_100A.2", "CD_101A_rd_CL", "CD_102.2", "CD_103", "CD_104", "CD_121", "CD_122A", "CD_123A", "CD_124", "CD_125", "CD_126A", "CD_127_rd_CL", "CD_128A", "CD_129A", "CD_130", "CD_131", "CD_132", "CD_133", "CD_134", "CD_135", "CD_136", "CD_137A", "CD_138", "CD_139", "CD_140", "CD_141", "CD_142", "CD_143", "CD_144"))

# Convert sequence table to long format
seqs_long <- seqs %>%
  select(sample_name, `B1`:`3165881_F`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`B1`:`3165881_F`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

# What is our per sample sequence depth?
sample_totals <- seqs_long %>%
  group_by(sample_name) %>%
  #group_by(sample_name, name) %>%
  summarise(total = sum(value))

# Create a list of samples to analyse that are above a minimum threshold 
keepers <- sample_totals %>%
  filter(total > 1500)

# Filter out the failed samples and convert counts to relative abundance
seqs_long <- seqs_long %>%
  filter(sample_name %in% keepers$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

seqs_long$sample_name <- factor(seqs_long$sample_name, levels = c("CD_1", "CD_2", "CD_3", "CD_4A.3", "CD_5", "CD_6A.3", "CD_7A.3", "CD_8A.3", "CD_9", "CD_10", "CD_11A", "CD_12", "CD_13A", "CD_14", "CD_15", "CD_16", "CD_17", "CD_18", "CD_19", "CD_20", "CD_21A", "CD_22A", "CD_23", "CD_24", "CD_41A", "CD_42A", "CD_43A", "CD_44A.2", "CD_45A", "CD_46A", "CD_47", "CD_48", "CD_49A", "CD_50_rd_CL", "CD_51.2", "CD_52", "CD_53", "CD_54A", "CD_55", "CD_56", "CD_57A", "CD_58A", "CD_59A", "CD_60", "CD_61A", "CD_62A", "CD_63.2", "CD_64A", "CD_81A", "CD_82A.2", "CD_83", "CD_84A", "CD_85A", "CD_86A_rd_CL", "CD_87", "CD_88A", "CD_89A", "CD_90A", "CD_91", "CD_92", "CD_93_rd_CL", "CD_94", "CD_95.2", "CD_96.2", "CD_97", "CD_98A", "CD_99", "CD_100A.2", "CD_101A_rd_CL", "CD_102.2", "CD_103", "CD_104", "CD_121", "CD_122A", "CD_123A", "CD_124", "CD_125", "CD_126A", "CD_127_rd_CL", "CD_128A", "CD_129A", "CD_130", "CD_131", "CD_132", "CD_133", "CD_134", "CD_135", "CD_136", "CD_137A", "CD_138", "CD_139", "CD_140", "CD_141", "CD_142", "CD_143", "CD_144"))

# Create a palette for each genus in Symbiodiniaceae
genera_2 <- seqs_long %>%
  distinct(name) %>%
  mutate(genus = case_when(
    str_sub(name, start = 1, end = 1) == "A" | str_detect(name, "_A") ~ 'Symbiodinium',
    str_sub(name, start = 1, end = 1) == "B" | str_detect(name, "_B") ~ 'Breviolum',
    str_sub(name, start = 1, end = 1) == "C" | str_detect(name, "_C") ~ 'Cladocopium',
    str_sub(name, start = 1, end = 1) == "D" | str_detect(name, "_D") ~ 'Durusdinium',
    str_sub(name, start = 1, end = 1) == "E" | str_detect(name, "_E") ~ 'Effrenium',
    str_sub(name, start = 1, end = 1) == "F" | str_detect(name, "_F") ~ 'Fugacium',
    str_sub(name, start = 1, end = 1) == "G" | str_detect(name, "_G") ~ 'Gerakladium',
    str_sub(name, start = 1, end = 1) == "A" | str_detect(name, "_A") ~ 'Symbiodinium',
    str_sub(name, start = 1, end = 1) == "H" | str_detect(name, "_H") ~ 'Halluxium',
    str_sub(name, start = 1, end = 1) == "I" | str_detect(name, "_I") ~ 'Symbiodinium_I',
    TRUE ~ "Unknown")) %>%
  distinct(genus) # If more than 8 genera - need to look at a new palette for the below

n <- length(levels(seqs_long$name))
seq_names <- sort(levels((seqs_long$name)))

a <- seq_names[str_sub(seq_names, 1, 1) == "A" | str_detect(seq_names, "_A")]
b <- seq_names[str_sub(seq_names, 1, 1) == "B" | str_detect(seq_names, "_B")]
c <- seq_names[str_sub(seq_names, 1, 1) == "C" | str_detect(seq_names, "_C")]
d <- seq_names[str_sub(seq_names, 1, 1) == "D" | str_detect(seq_names, "_D")]
#e <- seq_names[str_sub(seq_names, 1, 1) == "E" | str_detect(seq_names, "_E")]
f <- seq_names[str_sub(seq_names, 1, 1) == "F" | str_detect(seq_names, "_F")]
g <- seq_names[str_sub(seq_names, 1, 1) == "G" | str_detect(seq_names, "_G")]
h <- seq_names[str_sub(seq_names, 1, 1) == "H" | str_detect(seq_names, "_H")]
i <- seq_names[str_sub(seq_names, 1, 1) == "I" | str_detect(seq_names, "_I")]

b_pal <- randomcoloR::randomColor(count = length(b), hue = "purple")
c_pal <- randomcoloR::randomColor(count = length(c), hue = "green")
d_pal <- randomcoloR::randomColor(count = length(d), hue = "red")
f_pal <- randomcoloR::randomColor(count = length(f), hue = "blue")

names(b_pal) <- b
names(c_pal) <- c
names(d_pal) <- d
names(f_pal) <- f

# Merge the palettes and replace the non-profile sequences with grey
seqs_pal2 <- c(c_pal, d_pal, f_pal, b_pal)
```

# Read in and format the **profile** tables
```{r}
# Read in the profile data
profiles_raw <- read_tsv("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/20230421T034816_cduijser/its2_type_profiles/259_20230421T204816_DBV_20230422T042656.profiles.absolute.abund_and_meta.txt", skip = 6) %>% #first 6 rows is other text
    select(sample_name = `...2`, `C1d/C42.2/C1-C1bl-C3cg-C1b-C45c`:`D1bt/D6/D4-D1-D1cf-D1bs-D1ce-D1dr`) %>% # rename the second column as "sample_name" and select the profile columns
    filter(!is.na(sample_name)) #removes last 2 rows

profiles_long <- profiles_raw %>%
  pivot_longer(`C1d/C42.2/C1-C1bl-C3cg-C1b-C45c`:`D1bt/D6/D4-D1-D1cf-D1bs-D1ce-D1dr`) %>% # Convert profile table to long format
  #mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that do not appear in the Sequence dataframe above (were filtered out) => you removed samples based on sequencing depth (1500) above => these samples are filtered out now in the profile table as well because the profiles are meaningless if the sequences are meaningless
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  group_by(sample_name) %>%
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>%
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum <- profiles_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual <- left_join(profiles_sum, sample_totals, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = as.factor("non-profile sequences")) %>%
  left_join(., meta)

# Combine the profile and non-profile sequences
# Combine these so you can later plot them with the non-profile sequences in grey
profile_data <- rbind(profiles_long, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance

profile_data$sample_name <- factor(profile_data$sample_name, levels = c("CD_1", "CD_2", "CD_3", "CD_4A.3", "CD_5", "CD_6A.3", "CD_7A.3", "CD_8A.3", "CD_9", "CD_10", "CD_11A", "CD_12", "CD_13A", "CD_14", "CD_15", "CD_16", "CD_17", "CD_18", "CD_19", "CD_20", "CD_21A", "CD_22A", "CD_23", "CD_24", "CD_41A", "CD_42A", "CD_43A", "CD_44A.2", "CD_45A", "CD_46A", "CD_47", "CD_48", "CD_49A", "CD_50_rd_CL", "CD_51.2", "CD_52", "CD_53", "CD_54A", "CD_55", "CD_56", "CD_57A", "CD_58A", "CD_59A", "CD_60", "CD_61A", "CD_62A", "CD_63.2", "CD_64A", "CD_81A", "CD_82A.2", "CD_83", "CD_84A", "CD_85A", "CD_86A_rd_CL", "CD_87", "CD_88A", "CD_89A", "CD_90A", "CD_91", "CD_92", "CD_93_rd_CL", "CD_94", "CD_95.2", "CD_96.2", "CD_97", "CD_98A", "CD_99", "CD_100A.2", "CD_101A_rd_CL", "CD_102.2", "CD_103", "CD_104", "CD_121", "CD_122A", "CD_123A", "CD_124", "CD_125", "CD_126A", "CD_127_rd_CL", "CD_128A", "CD_129A", "CD_130", "CD_131", "CD_132", "CD_133", "CD_134", "CD_135", "CD_136", "CD_137A", "CD_138", "CD_139", "CD_140", "CD_141", "CD_142", "CD_143", "CD_144"))

# Create palette for profiles (this is a darker palette)
library(RColorBrewer)
(n <- length(levels(profile_data$name)))
profile_pal = brewer.pal(n=9, name="Set3")
names(profile_pal) <- levels(profile_data$name)

profile_pal_pie = brewer.pal(n=9, name="Dark2")
profile_pal_pie['Non-profile sequences'] <- "#808080" 
names(profile_pal_pie) <- levels(profile_data$name)

# Part of Supplementary Figure 10
ggplot(profile_data, aes(x = "", y = value_rel, fill = name)) +
  geom_bar(stat = "identity", width = 1, position="fill", color="transparent") +
  coord_polar("y", start = 0) +
  theme_void() +
  facet_wrap(~ population) +
  scale_fill_manual(values = profile_pal_pie) +
  labs(title = "Relative values of habitat in profile data", fill = "Name") +
  theme(panel.grid.minor = element_blank())
#ggsave("/Users/chiara/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/profiles_pie_HYBRID_cloneincl2.pdf")
```

# Plot with Symbiodiniaceae sequences and ITS2 type profiles in one graph
```{r}
# Join profiles and sequence data together into single dataframe
all_data <- rbind(seqs_long, profile_data)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal2, profile_pal_pie)
all_pal['Non-profile sequences'] <- "#808080"

# Save the color palette to a file
#saveRDS(all_pal, file = "color_palette.rds")
all_pal <- readRDS("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/color_palette.rds")

# Define the order of sample names based on habitat and colony_position for plotting
sample_order <- all_data %>%
  arrange(habitat, colony_position) %>%
  pull(sample_name) %>%
  unique()

# Reorder levels of sample_name factor
all_data$sample_name <- factor(all_data$sample_name, levels = sample_order)

# Figure 3 (adjusted in Adobe Illustrator)
all_data %>%
  arrange(name) %>%
  mutate(name = factor(name, levels = names(all_pal))) %>%
  ggplot(aes(sample_name, value_rel, fill = name)) +
  geom_bar(stat = "identity", width=1, size=0) +
  facet_wrap(~population, nrow = 1, scales = "free_x") +
  theme_bw() +
  theme(
    legend.position = "bottom",
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    #axis.text.x = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    axis.title.y = element_text(size = 10, face = "bold"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 12),
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text.x = element_text(size = 12, face = "bold")) +
  scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
  geom_hline(yintercept = 1, linewidth = 2) +
  guides(fill = guide_legend(title = "ITS2 type profile", nrow = 3)) +
  ylab("ITS2 sequence or type profile relative abundance") +
  xlab(element_blank())
#ggsave("seq_profile_HYBRID_big_cloneincl_site.pdf", width=10.0, height=8)
```

### Plot to make small inset of Cladocopium
```{r}
# Inset of Figure 3
all_data2 <- all_data[1:1640, ]

all_data2 %>%
  arrange(name) %>%
  mutate(name = factor(name, levels = names(all_pal))) %>%
  filter(population == "Mangrove") %>% # Filter data for population "Mangrove"
  ggplot(aes(sample_name, value_rel, fill = name)) +
  geom_bar(stat = "identity", width=1, size=0) +
  facet_wrap(~population, nrow = 1, scales = "free_x") +
  theme_bw() +
  theme(
    legend.position = "none",
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    #axis.text.x = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    axis.title.y = element_text(size = 10, face = "bold"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 12),
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text.x = element_text(size = 12, face = "bold")) +
  scale_fill_manual(values = all_pal) +
  guides(fill = guide_legend(title = "ITS2 type profile", nrow = 3)) +
  coord_cartesian(ylim = c(0.99, 1)) +  # Adjust y-axis limits
  #scale_y_continuous(limits = c(0.99, 1)) +  # Adjust y-axis limits
  ylab("ITS2 sequence") +
  xlab(element_blank())
#ggsave("seq_profile_HYBRID_inset.pdf", width=10.0, height=8)
ggplotly()
```


# Read in the sequences and create the unifrac distances
Unifrac measures the phylogenetic distance between sets of taxa in a phylogenetic tree as the fraction of the branch length of the tree that leads to descendants from either one environment or the other, but not both.

```{r}
# Import and filter sequence data
fasta <- read_fasta_df("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/20230421T034816_cduijser/post_med_seqs/259_20230421T204816_DBV_20230422T042656.seqs.fasta") %>%
  filter(label %in% seqs_long$name) %>% # keep only the sequences present in the sequence table above
  #filter(!str_detect(label, "A|G")) %>% # remove any clades/genera that you don't want included. This example removes any sequences from clade A and G.
  deframe() %>%
  as_dna() # convert to bioseq DNA format

# Create a kmer-based pairwise sequence similarity matrix
kdist <- fasta %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>% # test how different k size alters the interpretation
  as.matrix()
#Note - small K = less discriminating power. Large k = more discriminating power but significantly more compute time

# Use hierarchical clustering to create a phylogenetic tree based on the pairwise k-mer distances
tree <- kdist %>% phangorn::upgma()

# Create a wide count table to use in the weighted versions of the unifrac measurements
seqs_wide <- seqs_long %>%
  select(sample_name, name, value) %>% # need the sample names, the sequence names, and the count data
  #filter(!str_detect(name, "A|G")) %>% # again filter out the clades/genera that are not of interest to match the fasta above
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% # convert from long to wide;  values_fill = 0 will replace the NAs
  tibble::column_to_rownames(var = "sample_name") # sample names need to be column names

# Calculate the unifrac distance
unidist <- GUniFrac(seqs_wide, tree)
unifracs <- unidist$unifracs
# du <- unifracs[, , "d_1"]		# Weighted UniFrac
# du <- unifracs[, , "d_UW"]		# Unweighted UniFrac	
# du <- unifracs[, , "d_VAW"]		# Variance adjusted weighted UniFrac
# du <- unifracs[, , "d_0"]     	# GUniFrac with alpha 0  
 du <- unifracs[, , "d_0.5"]   	# GUniFrac with alpha 0.5 

# Hierarchical clustering of the samples into groups based on their pairwise unifrac distances
hclust_samps <- upgma(du)
```

Weighted-Unifrac takes into account the relative abundance of species/taxa shared between samples, whereas unweighted-Unifrac only considers presence/absence. Matt found gat GUnifrac with alpha 0.5 works best, is most successful.

# PERMANOVA of metadata factors (habitat and colony_position) and their explaining power of the unifrac distance
```{r}
# Convert unifrac matrix into dist class
dist <- as.dist(du, diag = FALSE)

# Check the dimensions of the matrix (should equal n x n samples of interest)
dim(du)

# format a metadata dataframe for the permanova
adonis_meta <- meta %>%
  select(sample_name, species, habitat, population, colony_ID, colony_position) %>%
  filter(sample_name %in% rownames(du)) %>% # keep only the samples of interest
  tibble::column_to_rownames(var = "sample_name") # vegan requires sample_names as row names

# call the permanova test and specify the model factors
# the below formula tests for an effect of habitat on the ITS2 unifrac distance, and then tests for an effect of colony_position, nested within each habitat
library(vegan)
adonis2(dist ~ population + population/colony_position, data = adonis_meta)

#adonis2(formula = dist ~ population + population/colony_position, data = adonis_meta)
#                           Df SumOfSqs      R2        F Pr(>F)    
#population                  2  18.2310 0.75952 142.1782  0.001 ***
#population:colony_position  3   0.0020 0.00008   0.0104  0.995    
#Residual                   90   5.7702 0.24039                    
#Total                      95  24.0031 1.00000  

betadisp <- betadisper(dist, adonis_meta$population)
plot(betadisp) # PCoA; Hybrid population has more dispersion than the reef and mangrove population
anova(betadisp) # this dispersion is significantly different across populations, so caution is encouraged in interpreting significance

# Notes: Population is significant - so the ITS2 sequence composition, according to pair-wise sample unifrac distances, differ across populations. However, mangrove/reef/hybrid populations have significantly different dispersion, which violates the assumption of PERMANOVA (caution to be applied). However if we consider that the mangrove profiles are distinct from reef profiles (see e.g. pie charts), it is likely that the population effect is true, and the dispersion differences are due to the within-colony sequence variability in the different populations (due to some colonies having C+B, and others only D). Colony position (shaded vs exposed) nested within each population, is not significant, however. Is this because the mangrove populations show almost zero differentiation across this factor? 
```


### PERMANOVA per population to check for effect of colony_position
```{r}
# Subset to Mangrove and perform the test of colony_position on this population only
mangrove_meta <- meta %>%
  select(sample_name, population, colony_position) %>% # select sample_name and the factors of interest
  filter(sample_name %in% rownames(du)) %>% # keep only the samples of interest
  filter(population == "Mangrove") %>% # keep the group of interest
  tibble::column_to_rownames(var = "sample_name")

# subset the unifrac distance matrix
mangrove_dist <- dist_subset(dist, rownames(mangrove_meta))

# Test colony_position on mangrove population only
adonis2(mangrove_dist ~ colony_position, data = mangrove_meta)

#adonis2(formula = mangrove_dist ~ colony_position, data = mangrove_meta)
#                Df  SumOfSqs      R2      F Pr(>F)  
#colony_position  1 0.0006662 0.07074 2.8927  0.014 *
#Residual        38 0.0087515 0.92926                
#Total           39 0.0094177 1.00000   

betadisp <- betadisper(mangrove_dist, mangrove_meta$colony_position)
plot(betadisp) 
anova(betadisp) # not significant, so PERMANOVA assumption of homogeneity of dispersion around group centroids is met

# Subset to Reef and perform the test of colony_position on this population only
reef_meta <- meta %>%
  select(sample_name, population, colony_position) %>% # select sample_name and the factors of interest
  filter(sample_name %in% rownames(du)) %>% # keep only the samples of interest
  filter(population == "Reef") %>% # keep the group of interest
  tibble::column_to_rownames(var = "sample_name")

# subset the unifrac distance matrix
reef_dist <- dist_subset(dist, rownames(reef_meta))

# Test colony_position on reef population only
adonis2(reef_dist ~ colony_position, data = reef_meta)

### NEW ### (old one significant but this one is not)
#adonis2(formula = reef_dist ~ colony_position, data = reef_meta)
#                Df  SumOfSqs      R2   F Pr(>F)  
#colony_position  1 0.0019697 0.08451 2.4  0.056 .
#Residual        26 0.0213375 0.91549             
#Total           27 0.0233072 1.00000   

betadisp <- betadisper(reef_dist, reef_meta$colony_position)
plot(betadisp) 
anova(betadisp) # not significant

# Subset to Hybrid and perform the test of colony_position on this population only
hybrid_meta <- meta %>%
  select(sample_name, population, colony_position) %>% # select sample_name and the factors of interest
  filter(sample_name %in% rownames(du)) %>% # keep only the samples of interest
  filter(population == "Hybrid") %>% # keep the group of interest
  tibble::column_to_rownames(var = "sample_name")

# subset the unifrac distance matrix
hybrid_dist <- dist_subset(dist, rownames(hybrid_meta))

# Test colony_position on hybrid population only
adonis2(hybrid_dist ~ colony_position, data = hybrid_meta)

#adonis2(formula = hybrid_dist ~ colony_position, data = hybrid_meta)
#                Df SumOfSqs      R2      F Pr(>F)
#colony_position  1   0.0007 0.00013 0.0033   0.92
#Residual        26   5.7098 0.99987              
#Total           27   5.7106 1.00000    

betadisp <- betadisper(hybrid_dist, hybrid_meta$colony_position)
plot(betadisp) 
anova(betadisp) # not significant
```


## PERMANOVA with just population
```{r}
# Check the dimensions of the matrix (should equal n x n samples of interest)
dim(du)

# format a metadata dataframe for the permanova
adonis_meta2 <- meta %>%
  select(sample_name, species, population) %>%
  filter(sample_name %in% rownames(du)) %>% # keep only the samples of interest
  tibble::column_to_rownames(var = "sample_name") # vegan requires sample_names as row names

# call the permanova test and specify the model factors
adonis(dist ~ population, data = adonis_meta)

###### POPULATION #######
#           Df SumsOfSqs MeanSqs F.Model      R2 Pr(>F)    
#population  2   19.7177  9.8589  269.92 0.85847  0.001 ***
#Residuals  89    3.2507  0.0365         0.14153           
#Total      91   22.9685                 1.00000           

betadisp <- betadisper(dist, adonis_meta$population)
plot(betadisp) # very far apart
anova(betadisp) # p-value =  3.052e-05 *** so caution is to be applied, there's significant dispersion which violates PERMANOVA assumptions
```

# Post-hoc PERMANOVA
```{r}
#TukeyHSD(betadisp) #TukeyHSD.betadisper; see TukeyHSD => results different from pairwise.adonis
library(devtools)
#install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis)
pairwise.adonis(dist, factors=adonis_meta$population, perm=999)
#pairwise.adonis(dist, factors=adonis_meta$habitat, perm=9999) #p.adjust.method = "bonferroni" by default
```


### PCoA unifrac distance
This will be a pcoa of the generalized unifrac distance with alpha 0.5 on which I performed a PERMANOVA. I will try to add colony_ID labels so I can compare this with host genetic data.

```{r}
du_dist <- dist

du_pcoa <- cmdscale(du_dist, eig=TRUE, k=nrow(du)-1)
du_eigen <- du_pcoa$eig
du_varprop <- du_eigen / sum(du_eigen)
du_cumprop <- cumsum(du_varprop)
du_df <- data.frame(PC1 = du_pcoa$points[,1],
                    PC2 = du_pcoa$points[,2],
                    metadata=adonis_meta,
                    VarProp=du_varprop,
                    CumProp=du_cumprop)
str(du_df)
#du_df$metadata.habitat <- as.factor(du_df$metadata.habitat)
#du_df$metadata.habitat <- factor(du_df$metadata.habitat, levels=c("Inner mangrove", "Outer mangrove", "Inner reef", "Outer reef"))

library(ggplot2)
library(plotly)
pca_col <- c("#1F78B4", "#33A02C", "orange") # "#A6CEE3"

# Supplementary Figure 9
ggplot(du_df, aes(x = PC1, y = PC2, color = metadata.population, shape=metadata.colony_position)) +
  geom_point(alpha=0.7, size=3) +
  scale_color_manual(values=pca_col, labels=c("Population 1", "Population 2", "Hybrid")) +
  scale_shape_manual(values = c(19, 17), labels=c("Shaded", "Exposed")) +
  facet_grid(. ~ metadata.population, scales = "free", labeller = labeller(metadata.population = c("Reef" = "Population 1", "Mangrove" = "Population 2", "Hybrid" = "Hybrid"))) +
  labs(
    fill = "Population",     # Change the legend title for the fill aesthetic
    color = "Population",    # Change the legend title for the color aesthetic
    shape = "Colony position" # Change the legend title for the shape aesthetic
  ) + 
  theme_bw() +
  theme(
    strip.text = element_text(size = 12),   # Facet wrap labels size
    axis.text.x = element_text(size = 11),  # X-axis labels size
    axis.text.y = element_text(size = 11),  # Y-axis labels size
    legend.text = element_text(size = 11),  # Legend text size
    legend.title = element_text(size = 12),  # Legend title size
  ) 
ggsave("PCoA_symbiont_HYBRID.pdf", width=7, height=4)
#ggsave("PCoA_symbiont_HYBRID.pdf", width=10, height=4)
ggplotly()
```


# Individual genera exploration
## Relative sequence total
```{r}
seqs_long_rel <- seqs %>%
  select(sample_name, `B1`:`3165881_F`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`B1`:`3165881_F`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

keepers_0 <- sample_totals %>%
  filter(total > 0)

# Filter out the failed samples and convert counts to relative abundance
seqs_long_unfiltered <- seqs_long_rel %>%
  filter(sample_name %in% keepers_0$sample_name) %>%
  group_by(sample_name) %>%
  #mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

# Group seqs_long_unfiltered by sample_name and calculate the total sequence count for each sample
seqs_long_unfiltered_sum <- seqs_long_unfiltered %>%
  group_by(sample_name) %>%
  summarise(total_seq_count = sum(value))
```

# Durusdinium
```{r}
seqs$sample_name <- factor(seqs$sample_name, levels = c("CD_1", "CD_2", "CD_3", "CD_4A.3", "CD_5", "CD_6A.3", "CD_7A.3", "CD_8A.3", "CD_9", "CD_10", "CD_11A", "CD_12", "CD_13A", "CD_14", "CD_15", "CD_16", "CD_17", "CD_18", "CD_19", "CD_20", "CD_21A", "CD_22A", "CD_23", "CD_24", "CD_41A", "CD_42A", "CD_43A", "CD_44A.2", "CD_45A", "CD_46A", "CD_47", "CD_48", "CD_49A", "CD_50_rd_CL", "CD_51.2", "CD_52", "CD_53", "CD_54A", "CD_55", "CD_56", "CD_57A", "CD_58A", "CD_59A", "CD_60", "CD_61A", "CD_62A", "CD_63.2", "CD_64A", "CD_81A", "CD_82A.2", "CD_83", "CD_84A", "CD_85A", "CD_86A_rd_CL", "CD_87", "CD_88A", "CD_89A", "CD_90A", "CD_91", "CD_92", "CD_93_rd_CL", "CD_94", "CD_95.2", "CD_96.2", "CD_97", "CD_98A", "CD_99", "CD_100A.2", "CD_101A_rd_CL", "CD_102.2", "CD_103", "CD_104", "CD_121", "CD_122A", "CD_123A", "CD_124", "CD_125", "CD_126A", "CD_127_rd_CL", "CD_128A", "CD_129A", "CD_130", "CD_131", "CD_132", "CD_133", "CD_134", "CD_135", "CD_136", "CD_137A", "CD_138", "CD_139", "CD_140", "CD_141", "CD_142", "CD_143", "CD_144"))

# Drop the clones (colony AB) levels to do the analyses with only one pair of the clones!
#seqs <- seqs[!(seqs$sample_name %in% c("CD_5", "CD_6A.3", "CD_7A.3", "CD_8A.3")), ]

# Import sequence table
seqs_D <- seqs

# Convert sequence table to long format
seqs_D_long <- seqs_D %>%
  select(sample_name, `D1bt`:`269341_D`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`D1bt`:`269341_D`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

# What is our per sample sequence depth?
sample_D_totals <- seqs_D_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))
sample_D_totals

# Create a list of samples to analyse that are above a minimum threshold 
# 1500 is an arbitrary number, mostly relates to the mean depth of each sample in the study
keepers_unfiltered <- sample_D_totals %>%
  filter(total > 0)

# Unfiltered and convert counts to relative abundance
seqs_D_long_unfiltered <- seqs_D_long %>%
  filter(sample_name %in% keepers_unfiltered$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

### Relative sequence abundance
# Join seqs_D_long_unfiltered with seqs_long_unfiltered_sum to get the total sequence count for each Durusdinium sequence in each sample (for all of the unfiltered sequences)
seqs_D_long_unfiltered_with_total_count <- seqs_D_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

# Calculate the percentage of Durusdinium sequences in each sample
seqs_D_long_unfiltered_with_total_count$value_relative_percent <- ((seqs_D_long_unfiltered_with_total_count$value / seqs_D_long_unfiltered_with_total_count$total_seq_count)*100)

# Plot
ggplot(seqs_D_long_unfiltered_with_total_count, aes(fill=name, y=value_relative_percent, x=sample_name)) +
    facet_wrap(.~ population, scales="free") +
    geom_bar(stat="identity") +
    scale_fill_manual(values = all_pal, breaks = levels(seqs_D_long_unfiltered_with_total_count$name)) +
    labs(x="", y="Relative Durusdinium sequence abundance \n(% from total)", title="Durusdinium") +
   theme(aspect.ratio = 1, legend.position = "right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.y = element_text(size=10, face="bold"), legend.title = element_text(size=12, face="bold"), legend.text = element_text(size=12), strip.text.x = element_text(size = 12, face="bold"))

##Total percentage within each of the four habitats that Durusdinium sequences make up in the *unfiltered* data. Not sure if I have to divide by number of species with those sequences of total number of species?** => have to divide by total number of individuals in that habitat

sum(seqs_D_long_unfiltered_with_total_count$value_relative_percent[seqs_D_long_unfiltered_with_total_count$population=="Mangrove"]) / 40 # 99.96213
sum(seqs_D_long_unfiltered_with_total_count$value_relative_percent[seqs_D_long_unfiltered_with_total_count$population=="Reef"]) / 28 # 0.01426498
sum(seqs_D_long_unfiltered_with_total_count$value_relative_percent[seqs_D_long_unfiltered_with_total_count$population=="Hybrid"]) / 28 # 28.50506
```


# Cladocopium
```{r}
seqs_C_long <- seqs %>%
  select(sample_name, `C1d`:`C15by`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`C1d`:`C15by`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

keepers_0 <- sample_totals %>%
  filter(total > 0)

# Filter out the failed samples and convert counts to relative abundance
seqs_C_long_unfiltered <- seqs_C_long %>%
  filter(sample_name %in% keepers_0$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

### Relative sequence abundance
# Join seqs_C_long_unfiltered with seqs_long_unfiltered_sum to get the total sequence count for each Cladocopium sequence in each sample (for all of the unfiltered sequences)
seqs_C_long_unfiltered_with_total_count <- seqs_C_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

# Calculate the percentage of Cladocopium sequences in each sample
seqs_C_long_unfiltered_with_total_count$value_relative_percent <- ((seqs_C_long_unfiltered_with_total_count$value / seqs_C_long_unfiltered_with_total_count$total_seq_count)*100)

# Plot
ggplot(seqs_C_long_unfiltered_with_total_count, aes(fill=name, y=value_relative_percent, x=sample_name)) +
    facet_wrap(.~ population, scales="free") +
    geom_bar(stat="identity") +
    scale_fill_manual(values = all_pal, breaks = levels(seqs_C_long_unfiltered_with_total_count$name)) +
    labs(x="", y="Relative Cladocopium sequence abundance \n(% from total)", title="Cladocopium") +
   theme(aspect.ratio = 1, legend.position = "right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.y = element_text(size=10, face="bold"), legend.title = element_text(size=12, face="bold"), legend.text = element_text(size=12), strip.text.x = element_text(size = 12, face="bold"))

##Total percentage within each of the four habitats that Cladocopium sequences make up in the *unfiltered* data. Not sure if I have to divide by number of species with those sequences of total number of species?** => have to divide by total number of individuals in that habitat

sum(seqs_C_long_unfiltered_with_total_count$value_relative_percent[seqs_C_long_unfiltered_with_total_count$population=="Mangrove"]) / 40 # 0.0378743
sum(seqs_C_long_unfiltered_with_total_count$value_relative_percent[seqs_C_long_unfiltered_with_total_count$population=="Reef"]) / 28 # 99.91137
sum(seqs_C_long_unfiltered_with_total_count$value_relative_percent[seqs_C_long_unfiltered_with_total_count$population=="Hybrid"]) / 28 # 71.45489
```


# Breviolum
```{r}
# Import sequence table
seqs_B <- seqs

# Convert sequence table to long format
seqs_B_long <- seqs_B %>%
  select(sample_name, `B1`:`3165889_B`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`B1`:`3165889_B`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

# What is our per sample sequence depth?
sample_B_totals <- seqs_B_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))
sample_B_totals

# Create a list of samples to analyse that are above a minimum threshold 
keepers_unfiltered <- sample_B_totals %>%
  filter(total > 0)

# Unfiltered and convert counts to relative abundance
seqs_B_long_unfiltered <- seqs_B_long %>%
  filter(sample_name %in% keepers_unfiltered$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

seqs_B_long_unfiltered_with_total_count <- seqs_B_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

### Relative sequence abundance
# Join seqs_B_long_unfiltered with seqs_long_unfiltered_sum to get the total sequence count for each Breviolum sequence in each sample (for all of the unfiltered sequences)
seqs_B_long_unfiltered_with_total_count <- seqs_B_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

# Calculate the percentage of Breviolum sequences in each sample
seqs_B_long_unfiltered_with_total_count$value_relative_percent <- ((seqs_B_long_unfiltered_with_total_count$value / seqs_B_long_unfiltered_with_total_count$total_seq_count)*100)

# Plot
ggplot(seqs_B_long_unfiltered_with_total_count, aes(fill=name, y=value_relative_percent, x=sample_name)) +
    facet_wrap(.~ population, scales="free") +
    geom_bar(stat="identity") +
    scale_fill_manual(values = all_pal, breaks = levels(seqs_B_long_unfiltered_with_total_count$name)) +
    labs(x="", y="Relative Breviolum sequence abundance \n(% from total)", title="Breviolum") +
   theme(aspect.ratio = 1, legend.position = "right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.y = element_text(size=10, face="bold"), legend.title = element_text(size=12, face="bold"), legend.text = element_text(size=12), strip.text.x = element_text(size = 12, face="bold"))

##Total percentage within each of the four habitats that Breviolum sequences make up in the *unfiltered* data. Not sure if I have to divide by number of species with those sequences of total number of species?** => have to divide by total number of individuals in that habitat

sum(seqs_B_long_unfiltered_with_total_count$value_relative_percent[seqs_B_long_unfiltered_with_total_count$population=="Mangrove"]) / 40 # 0
sum(seqs_B_long_unfiltered_with_total_count$value_relative_percent[seqs_B_long_unfiltered_with_total_count$population=="Reef"]) / 28 # 0.06960674
sum(seqs_B_long_unfiltered_with_total_count$value_relative_percent[seqs_B_long_unfiltered_with_total_count$population=="Hybrid"]) / 28 # 0.04004105
```


# Fugacium
```{r}
# Import sequence table
seqs_F <- seqs

# Convert sequence table to long format
seqs_F_long <- seqs_F %>%
  select(sample_name, `769286_F`:`3165881_F`) %>% # Select sample_names and the each column contain sequence count data; check colnames(seqs)
  pivot_longer(`769286_F`:`3165881_F`) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>% # Remove non-name samples (tutorial specific)
  left_join(., meta) # add in your metadata

# What is our per sample sequence depth?
sample_F_totals <- seqs_F_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))
sample_F_totals

# Create a list of samples to analyse that are above a minimum threshold 
keepers_unfiltered <- sample_F_totals %>%
  filter(total > 0)

# Unfiltered and convert counts to relative abundance
seqs_F_long_unfiltered <- seqs_F_long %>%
  filter(sample_name %in% keepers_unfiltered$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sequence names a factor

seqs_F_long_unfiltered_with_total_count <- seqs_F_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

### Relative sequence abundance
# Join seqs_F_long_unfiltered with seqs_long_unfiltered_sum to get the total sequence count for each Fugacium sequence in each sample (for all of the unfiltered sequences)
seqs_F_long_unfiltered_with_total_count <- seqs_F_long_unfiltered %>%
  left_join(seqs_long_unfiltered_sum, by = "sample_name")

# Calculate the percentage of Fugacium sequences in each sample
seqs_F_long_unfiltered_with_total_count$value_relative_percent <- ((seqs_F_long_unfiltered_with_total_count$value / seqs_F_long_unfiltered_with_total_count$total_seq_count)*100)

# Plot
ggplot(seqs_F_long_unfiltered_with_total_count, aes(fill=name, y=value_relative_percent, x=sample_name)) +
    facet_wrap(.~ population, scales="free") +
    geom_bar(stat="identity") +
    scale_fill_manual(values = all_pal, breaks = levels(seqs_F_long_unfiltered_with_total_count$name)) +
    labs(x="", y="Relative Fugacium sequence abundance \n(% from total)", title="Fugacium") +
   theme(aspect.ratio = 1, legend.position = "right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.y = element_text(size=10, face="bold"), legend.title = element_text(size=12, face="bold"), legend.text = element_text(size=12), strip.text.x = element_text(size = 12, face="bold"))

##Total percentage within each of the four habitats that Fugacium sequences make up in the *unfiltered* data. Not sure if I have to divide by number of species with those sequences of total number of species?** => have to divide by total number of individuals in that habitat

sum(seqs_F_long_unfiltered_with_total_count$value_relative_percent[seqs_F_long_unfiltered_with_total_count$population=="Mangrove"]) / 40 # 0
sum(seqs_F_long_unfiltered_with_total_count$value_relative_percent[seqs_F_long_unfiltered_with_total_count$population=="Reef"]) / 28 # 0.0047621
sum(seqs_F_long_unfiltered_with_total_count$value_relative_percent[seqs_F_long_unfiltered_with_total_count$population=="Hybrid"]) / 28 # 0
```


### Create dataframe with all background sequences for plotting
```{r}
# Combine the dataframes using rbind
combined_df <- rbind(seqs_D_long_unfiltered_with_total_count,
                     seqs_C_long_unfiltered_with_total_count,
                     seqs_B_long_unfiltered_with_total_count,
                     seqs_F_long_unfiltered_with_total_count)

Reef <- rbind(seqs_D_long_unfiltered_with_total_count,
                     seqs_B_long_unfiltered_with_total_count,
                     seqs_F_long_unfiltered_with_total_count)

Mangrove <- rbind(seqs_C_long_unfiltered_with_total_count)

Hybrid <- rbind(seqs_D_long_unfiltered_with_total_count,
                     seqs_C_long_unfiltered_with_total_count,
                     seqs_B_long_unfiltered_with_total_count)
```


### Create plot
```{r}
Reef$colony_position <- factor(Reef$colony_position, labels=c("Shaded", "Exposed"))
Mangrove$colony_position <- factor(Mangrove$colony_position, labels=c("Shaded", "Exposed"))
Hybrid$colony_position <- factor(Hybrid$colony_position, labels=c("Shaded", "Exposed"))

### Supplementary Figure 8 (adjusted in Adobe Illustrator)
# Reorder the levels of sample_name based on habitat levels
Reef <- mutate(Reef, sample_name = factor(sample_name, levels = unique(Reef$sample_name[order(Reef$habitat)])))

# Plot with reordered samples
(back_Reef_colpos <- ggplot(data = subset(Reef, population == "Reef"), aes(fill=name, y=value_relative_percent, x=sample_name)) +
  facet_wrap(.~ colony_position, labeller = labeller(colony_position = function(labels) paste("Population 1\n", labels)), scales="free_x") + # Reef
  geom_bar(stat="identity") +
  scale_fill_manual(values = all_pal) +
  labs(x="", y="Relative background sequence \nabundance (% from total)") +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    legend.position = "none",
    #axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),  # Remove x-axis ticks
    axis.title.y = element_text(size=12, face="bold"),
    axis.text.y = element_text(size = 10),
    panel.grid.major = element_blank(),
    strip.text.x = element_text(size = 12, face="bold")
  ) +
  scale_y_continuous(labels = function(x) sprintf("%.2f", x)))

# Reorder the levels of sample_name based on habitat levels
Mangrove <- mutate(Mangrove, sample_name = factor(sample_name, levels = unique(Mangrove$sample_name[order(Mangrove$habitat)])))

(back_Mangrove_colpos <- ggplot(data = subset(Mangrove, population == "Mangrove"), aes(fill=name, y=value_relative_percent, x=sample_name)) + 
  facet_wrap(.~ colony_position, labeller = labeller(colony_position = function(labels) paste("Population 2\n", labels)), scales="free_x") + # Mangrove
    geom_bar(stat="identity") +
    #scale_fill_manual(values = all_pal, breaks = levels(seqs_long_unfiltered_with_total_count$name)) +
    scale_fill_manual(values = all_pal) +
    labs(x="", y="Relative background sequence \nabundance (% from total)") +
    theme_bw() +
    theme(
        aspect.ratio = 1,
        legend.position = "none",
        #axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        axis.text.x = element_blank(),  # Remove x-axis labels
        axis.ticks.x = element_blank(),  # Remove x-axis ticks
        axis.title.y = element_text(size=12, face="bold"),
        axis.text.y = element_text(size = 10),
        panel.grid.major = element_blank(),
        strip.text.x = element_text(size = 12, face="bold")  # Comment corrected here
    ) +
    scale_y_continuous(labels = function(x) sprintf("%.2f", x)))  # Added y-axis label formatting

# Define the specific sample names you want to include
specific_sample_names <- c("CD_7A.3", "CD_8A.3", "CD_127_rd_CL", "CD_128A", "CD_131", "CD_129A", "CD_137A", "CD_138")
# Filter the data to include only the specific sample names
Hybrid_filtered <- subset(Hybrid, population == "Hybrid" & sample_name %in% specific_sample_names)

# Reorder the levels of sample_name based on habitat levels
Hybrid_filtered <- mutate(Hybrid_filtered, sample_name = factor(sample_name, levels = unique(Hybrid_filtered$sample_name[order(Hybrid_filtered$habitat)])))

# Plot the filtered data
(back_Hybrid_colpos <- ggplot(data = Hybrid_filtered, aes(fill = name, y = value_relative_percent, x = sample_name)) +
  facet_wrap(.~ colony_position, labeller = labeller(colony_position = function(labels) paste("Hybrid\n", labels)), scales = "free_x") +
  geom_bar(stat = "identity") +
    #scale_fill_manual(values = all_pal, breaks = levels(seqs_long_unfiltered_with_total_count$name)) +
    scale_fill_manual(values = all_pal) +
  labs(x = "", y = "Relative background sequence \nabundance (% from total)") +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    legend.position = "none",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    #axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(),  # Remove x-axis ticks
    axis.title.y = element_text(size = 12, face = "bold"),
    axis.text.y = element_text(size = 10),
    panel.grid.major = element_blank(),
    strip.text.x = element_text(size = 12, face = "bold")
  ) +
  scale_y_continuous(labels = function(x) sprintf("%.2f", x), limits = c(0, 0.1)))

# Save the plots
#ggsave("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/back_Reef_colpos_cloneincl_2.0.pdf", plot = back_Reef_colpos)
#ggsave("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/back_Mangrove_colpos_cloneincl_2.0.pdf", plot = back_Mangrove_colpos)
#ggsave("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/Sequences_Profiles_PERMOVA/back_Hybrid_colpos_cloneincl_2.0.pdf", plot = back_Hybrid_colpos)
```






