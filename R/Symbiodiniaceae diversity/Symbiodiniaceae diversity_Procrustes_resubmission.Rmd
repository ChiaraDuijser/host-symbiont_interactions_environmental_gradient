---
title: "Symbiodiniaceae diversity - Symportal_merger (Procrustes)"
author: "Chiara Duijser, Matthew Nitschke"
date: "06/02/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require("knitr")
opts_knit$set(root.dir = "/Users/chiara/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_working/DNA extractions/ITS2")
```

# Set working directory 
```{r user_definitions}
#ITS2 <- "~/ITS2"
#ITS2 <- "/Volumes/TRACK/MSc - Research Project 2/Data : analyses/Symbiodiniaceae diversity/PCoA_Procrustes"
#ITS2 <- "~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/PCoA_Procrustes"
#setwd(ITS2)

getwd()
#setwd("/Users/Chiara/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_working/DNA extractions/ITS2")
#setwd("/Users/chiara/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_working/DNA extractions/ITS2")
#setwd("/Users/chiara/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/Symbiodiniaceae diversity/PCoA_Procrustes")
```

```{r}
library(tidyverse)
library(bioseq)
library(kmer)
library(GUniFrac)
library(randomcoloR)
library(plotly)
source("functions.R")
```

```{r}
rd <- sort(list.files("datasets/", recursive = "false", full.names = TRUE))
ml <- sort(list.files("metadata/", recursive = "false", full.names = TRUE))

rd
ml

### If Error in file(con, "r") : invalid 'description' argument ==> make sure all files are downloaded from the iCloud!!!
merged_data <- data.frame()
for(i in 1:length(rd)){
  seq_path <- paste0(rd[i], "/post_med_seqs/")
  seq_file <- list.files(seq_path, pattern = "seqs.absolute.abund_and_meta.txt", recursive = FALSE, full.names = TRUE)
  seqs <- read_tsv(seq_file) %>%
  filter(!(is.na(sample_name)))
  
  #meta <- read_csv2(ml[i]) #csv2 because ; for field separator
  meta <- read_csv(ml[i])  # Adjust column types as needed
  meta <- as.data.frame(meta)
  fasta_file <- list.files(paste0(rd[i], "/post_med_seqs/"), pattern = ".fasta", recursive = FALSE, full.names = TRUE)  
  fasta <- read_fasta_df(fasta_file)
  
  seqs_long <- seqs %>%
  dplyr::select(sample_name, collection_depth:last_col(), -collection_depth) %>% # Select sample_names and the each column contain sequence count data
  pivot_longer(-sample_name) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>%
  left_join(., fasta, by = c("name" = "label")) %>%
  left_join(., meta, by = c("sample_name"))
  
  merged_data <- rbind(merged_data, seqs_long)
}

name_update <- merged_data %>%
  distinct(name, sequence) %>%
  group_by(sequence) %>%
  summarise(duplicates = paste0(name, collapse = '-')) %>%
  separate(duplicates, into = c("A", "B"), sep = "-") %>%
  mutate(final_name = case_when(is.na(B) ~ A,
                                !is.na(as.numeric(str_sub(A, 1, 1))) & is.na(B) ~ A,
                                !is.na(as.numeric(str_sub(A, 1, 1))) ~ B)) %>%
  select(sequence, final_name)

merged_data <- merged_data %>%
  left_join(., name_update) %>%
  select(-name) %>%
  dplyr::rename(name = final_name) %>%
  mutate(name = as.factor(name)) %>%
  group_by(sample_name, symportal_run_id) %>%
  mutate(sample_name = paste0(sample_name, "-", cur_group_id())) %>% # prevent sample name duplicates from run to run
  ungroup()
```

# Add metadata

```{r}
# Create a kmer-based pairwise sequence similarity matrix
kdist <- merged_data %>%
  select(name, sequence) %>%
  distinct(name, sequence) %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAbin() %>%
  kdistance(k = 8, residues = "DNA", method = "edgar") %>% # test how different k size alters the interpretation
  as.matrix()
# Note - small K = less discriminating power. Large k = more discriminating power but significantly more compute time

# Use hierarchical clustering to create a phylogenetic tree based on the pairwise k-mer distances
k_tree <- kdist %>% phangorn::upgma()

# Create a wide count table to use in the weighted versions of the unifrac measurements
seqs_wide <- merged_data %>%
  select(sample_name, name, value) %>% # need the sample names, the sequence names, and the count data
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% # convert from long to wide
  tibble::column_to_rownames(var = "sample_name") # sample names need to be column names

# Calculate the unifrac distance
unidist <- GUniFrac(seqs_wide, k_tree)
unifracs <- unidist$unifracs
du <- unifracs[, , "d_0.5"] # GUniFrac with alpha 0.5 

# Hierarchical clustering of the samples into groups based on their pairwise unifrac distances
hclust_samps <- phangorn::upgma(du)
s_tree <- ggtree::ggtree(hclust_samps) +
  scale_x_reverse() +
  theme(aspect.ratio = 1.8)

s_order <- s_tree$data %>% filter(isTip == TRUE) %>% arrange(y) %>% pull(label)
```

```{r}
totals <- merged_data %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))
```


# Procrustes rotation
Info on procrustes rotation: https://john-quensen.com/tutorials/procrustes-analysis/
I have to remove colony CD from my ITS2 dataset since this colony failed dartseq and so there's no data in my genlight object for CD. They have to have the same individuals otherwise it doesn't work.
I also have to remove the samples from the clone (colony AB) because these are removed from the dartR object, otherwise the sample numbers aren't the same and the Procrustes doesn't work.

```{r}
# Drop the clones (colony AB) levels to do the analyses with only one pair of the clones!
merged_data <- merged_data[!(merged_data$sample_name %in% c("CD_5-58", "CD_6A.3-74", "CD_7A.3-75", "CD_8A.3-85")), ]

merged_colony <- merged_data %>%
  select(-sample_name) %>%
  filter(colony_ID != "CD") %>%
  rename(sample_name = "DART_new") # changed from DART_wrong to DART_new based on new numbering in gl with gl.report.callrate()
#merged_colony$sample_name <- as.character(merged_colony$sample_name) #convert DART_wrong/sample_name from numeric to character variable
merged_colony$sample_name <- as.factor(merged_colony$sample_name)
levels(merged_colony$sample_name)

#### Make sure to use correct new dartIDs since different based on different gl.report.callrate()
#### Also make sure to remove 20.1 as a clone because the genlight object will have this one removed as well

seqs_wide_pr <- merged_colony %>%
  select(sample_name, name, value) %>% 
  pivot_wider(names_from = name, values_from = value, values_fn = mean, values_fill = 0) %>% # I added values_fn = mean because we have several values => 4 values/technical replicates per sample_name
  tibble::column_to_rownames(var = "sample_name")

kdist <- merged_colony %>%
  select(name, sequence) %>%
  distinct(name, sequence) %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAbin() %>%
  kdistance(k = 8, residues = "DNA", method = "edgar") %>% # test how different k size alters the interpretation
  as.matrix()
# Note - small K = less discriminating power. Large k = more discriminating power but significantly more compute time

# Use hierarchical clustering to create a phylogenetic tree based on the pairwise k-mer distances
k_tree <- kdist %>% phangorn::upgma()

# Calculate the unifrac distance
unidist <- GUniFrac(seqs_wide_pr, k_tree)
unifracs <- unidist$unifracs
du <- unifracs[, , "d_0.5"] # GUniFrac with alpha 0.5
dist_du <- as.dist(du, diag=FALSE)

# make sure that the names in the gl.dist.ind object from dart match exactly the names in the unifrac distance object
# Check if you can do Procrustes ordination on two different distance matrices. Dart is Euclidean, symbiont is unifrac.
# Names match but different order in distance matrix => is that a problem?
library(dartR)
#gl5_procrustes <- readRDS("C:/Users/156010/OneDrive - UTS/Documents/DArTseq - R #files/Report-DPoc22-7677/gl5.Rdata")

# glp3 with 3 populations (mangrove, reef, hybrids) and hybrids included and clone removed
glp3_procrustes <- readRDS("~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_FINAL/SNP genotyping/Report-DPoc22-7677/glp3_hybrids_included.Rdata")

matrix <- gl.dist.ind(glp3_procrustes, method="euclidean", scale=TRUE)
dist_host <- as.dist(matrix, diag = FALSE)

str(dist_du) #ITS2
str(dist_host) #host
# Same number of labels but not the same order, is that a problem?

library(vegan)
pr <- procrustes(dist_du, dist_host, symmetric = FALSE) #perform procrustes on the two separate distance matrices
pr
summary(pr)
plot(pr, type="text")
plot(pr)
#ggsave(filename=paste0(ITS2, "/Symbiodiniaceae_diversity_Procrustes_", ".pdf"), width=10, height=3) 
# This shows the host PCoA and you see they all point towards the same symbiont communities within reef (top right) and mangrove (bottom left)

# It makes more sense to put the PCA for the host data first because the ITS2 data is being fit to the host data, i.e. the target matrix. It is logical that ITS2 depend on the host, but not the other way around. As we will see, however, the order makes no difference when making a test of significance.
#pr2 <- procrustes(dist_host, dist_du) #perform procrustes on the two separate distance matrices
#pr2
#summary(pr2)
#plot(pr2, type="text")
#plot(pr2)

# This is nice, but how do I know the habitats now?
protest(X = dist_host, Y = dist_du, scores = "sites", permutations = 999)
```