---
title: "Symbiodiniaceae diversity - Symportal_merger (Procrustes)"
author: "Chiara Duijser, Matthew Nitschke"
date: "06/02/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require("knitr")
opts_knit$set(root.dir = "/Users/chiara/Library/Mobile Documents/com~apple~CloudDocs/Documents/Studie/UvA Master/Research Project/Research Project 2 - UTS/Data_working/DNA extractions/ITS2")
```

# Set working directory 
```{r user_definitions}
getwd()
```

```{r}
library(tidyverse)
library(bioseq)
library(kmer)
library(GUniFrac)
library(randomcoloR)
library(plotly)
source("functions.R")
```

```{r}
rd <- sort(list.files("datasets/", recursive = "false", full.names = TRUE))
ml <- sort(list.files("metadata/", recursive = "false", full.names = TRUE))

rd
ml

### If Error in file(con, "r") : invalid 'description' argument ==> make sure all files are downloaded from the iCloud!!!
merged_data <- data.frame()
for(i in 1:length(rd)){
  seq_path <- paste0(rd[i], "/post_med_seqs/")
  seq_file <- list.files(seq_path, pattern = "seqs.absolute.abund_and_meta.txt", recursive = FALSE, full.names = TRUE)
  seqs <- read_tsv(seq_file) %>%
  filter(!(is.na(sample_name)))
  
  #meta <- read_csv2(ml[i]) #csv2 because ; for field separator
  meta <- read_csv(ml[i])  # Adjust column types as needed
  meta <- as.data.frame(meta)
  fasta_file <- list.files(paste0(rd[i], "/post_med_seqs/"), pattern = ".fasta", recursive = FALSE, full.names = TRUE)  
  fasta <- read_fasta_df(fasta_file)
  
  seqs_long <- seqs %>%
  dplyr::select(sample_name, collection_depth:last_col(), -collection_depth) %>% # Select sample_names and the each column contain sequence count data
  pivot_longer(-sample_name) %>% # make into long dataframe
  filter(value > 0) %>% # Remove zero values
  filter(!(is.na(sample_name))) %>%
  left_join(., fasta, by = c("name" = "label")) %>%
  left_join(., meta, by = c("sample_name"))
  
  merged_data <- rbind(merged_data, seqs_long)
}

name_update <- merged_data %>%
  distinct(name, sequence) %>%
  group_by(sequence) %>%
  summarise(duplicates = paste0(name, collapse = '-')) %>%
  separate(duplicates, into = c("A", "B"), sep = "-") %>%
  mutate(final_name = case_when(is.na(B) ~ A,
                                !is.na(as.numeric(str_sub(A, 1, 1))) & is.na(B) ~ A,
                                !is.na(as.numeric(str_sub(A, 1, 1))) ~ B)) %>%
  select(sequence, final_name)

merged_data <- merged_data %>%
  left_join(., name_update) %>%
  select(-name) %>%
  dplyr::rename(name = final_name) %>%
  mutate(name = as.factor(name)) %>%
  group_by(sample_name, symportal_run_id) %>%
  mutate(sample_name = paste0(sample_name, "-", cur_group_id())) %>% # prevent sample name duplicates from run to run
  ungroup()
```

# Add metadata

```{r}
# Create a kmer-based pairwise sequence similarity matrix
kdist <- merged_data %>%
  select(name, sequence) %>%
  distinct(name, sequence) %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAbin() %>%
  kdistance(k = 8, residues = "DNA", method = "edgar") %>% # test how different k size alters the interpretation
  as.matrix()
# Note - small K = less discriminating power. Large k = more discriminating power but significantly more compute time

# Use hierarchical clustering to create a phylogenetic tree based on the pairwise k-mer distances
k_tree <- kdist %>% phangorn::upgma()

# Create a wide count table to use in the weighted versions of the unifrac measurements
seqs_wide <- merged_data %>%
  select(sample_name, name, value) %>% # need the sample names, the sequence names, and the count data
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% # convert from long to wide
  tibble::column_to_rownames(var = "sample_name") # sample names need to be column names

# Calculate the unifrac distance
unidist <- GUniFrac(seqs_wide, k_tree)
unifracs <- unidist$unifracs
du <- unifracs[, , "d_0.5"] # GUniFrac with alpha 0.5 

# Hierarchical clustering of the samples into groups based on their pairwise unifrac distances
hclust_samps <- phangorn::upgma(du)
s_tree <- ggtree::ggtree(hclust_samps) +
  scale_x_reverse() +
  theme(aspect.ratio = 1.8)

s_order <- s_tree$data %>% filter(isTip == TRUE) %>% arrange(y) %>% pull(label)
```

```{r}
totals <- merged_data %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))
```


# Procrustes rotation
Remove colony CD from ITS2 dataset since this colony failed dartseq and so there's no data in my genlight object for CD. They have to have the same individuals otherwise it doesn't work. Also remove the samples from the clone (colony AB) because these are removed from the dartR object, otherwise the sample numbers aren't the same and the Procrustes doesn't work.

```{r}
# Drop the clones (colony AB) levels to do the analyses with only one pair of the clones!
merged_data <- merged_data[!(merged_data$sample_name %in% c("CD_5-58", "CD_6A.3-74", "CD_7A.3-75", "CD_8A.3-85")), ]

merged_colony <- merged_data %>%
  select(-sample_name) %>%
  filter(colony_ID != "CD") %>%
  rename(sample_name = "DART_new") # changed from DART_wrong to DART_new based on new numbering in gl with gl.report.callrate()
#merged_colony$sample_name <- as.character(merged_colony$sample_name) #convert DART_wrong/sample_name from numeric to character variable
merged_colony$sample_name <- as.factor(merged_colony$sample_name)
levels(merged_colony$sample_name)

# Make sure to use correct new dartIDs since different based on different gl.report.callrate()
# Also make sure to remove 20.1 as a clone because the genlight object will have this one removed as well

seqs_wide_pr <- merged_colony %>%
  select(sample_name, name, value) %>% 
  pivot_wider(names_from = name, values_from = value, values_fn = mean, values_fill = 0) %>% # I added values_fn = mean because we have several values => 4 values/technical replicates per sample_name
  tibble::column_to_rownames(var = "sample_name")

kdist <- merged_colony %>%
  select(name, sequence) %>%
  distinct(name, sequence) %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAbin() %>%
  kdistance(k = 8, residues = "DNA", method = "edgar") %>% # test how different k size alters the interpretation
  as.matrix()
# Note - small K = less discriminating power. Large k = more discriminating power but significantly more compute time

# Use hierarchical clustering to create a phylogenetic tree based on the pairwise k-mer distances
k_tree <- kdist %>% phangorn::upgma()

# Calculate the unifrac distance
unidist <- GUniFrac(seqs_wide_pr, k_tree)
unifracs <- unidist$unifracs
du <- unifracs[, , "d_0.5"] # GUniFrac with alpha 0.5
dist_du <- as.dist(du, diag=FALSE)

# Make sure that the names in the gl.dist.ind object from dart match exactly the names in the unifrac distance object
library(dartR)

# glp3 with 3 populations (mangrove, reef, hybrids) and hybrids included and clone removed
glp3_procrustes <- readRDS("../SNP genotyping/Report-DPoc22-7677/glp3_hybrids_included.Rdata")

matrix <- gl.dist.ind(glp3_procrustes, method="euclidean", scale=TRUE)
dist_host <- as.dist(matrix, diag = FALSE)

str(dist_du) #ITS2
str(dist_host) #host

library(vegan)
pr <- procrustes(dist_du, dist_host, symmetric = FALSE) #perform procrustes on the two separate distance matrices
pr
summary(pr)
plot(pr, type="text")
plot(pr)
# This shows the host PCoA and you see they all point towards the same symbiont communities within reef (top right) and mangrove (bottom left)

# Significance test
protest(X = dist_host, Y = dist_du, scores = "sites", permutations = 999)
```
